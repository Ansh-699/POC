use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer, Mint};

declare_id!("YBuXX3zr2he3tiZgzbethftfi65S4oThG6u46QniRNG");

#[program]
pub mod vulnerable_defi_protocol {
    use super::*;

    /// Initialize the protocol configuration
    pub fn initialize(ctx: Context<Initialize>, admin: Pubkey) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.admin = admin;
        config.total_markets = 0;
        Ok(())
    }

    /// VULNERABILITY #1: No whitelist check for oracle creation
    /// Anyone can create an oracle and become its authority
    pub fn create_oracle(ctx: Context<CreateOracle>, price: u64) -> Result<()> {
        let oracle = &mut ctx.accounts.oracle;
        oracle.price = price;
        oracle.authority = ctx.accounts.signer.key(); // Attacker becomes authority
        oracle.last_update = Clock::get()?.unix_timestamp;
        msg!("Oracle created by: {}", ctx.accounts.signer.key());
        msg!("Oracle price: {}", price);
        Ok(())
    }

    /// VULNERABILITY #1 & #7: No authority validation
    /// Any signer can update any oracle
    pub fn update_oracle(ctx: Context<UpdateOracle>, new_price: u64) -> Result<()> {
        let oracle = &mut ctx.accounts.oracle;
        oracle.price = new_price;
        oracle.last_update = Clock::get()?.unix_timestamp;
        // MISSING: require!(ctx.accounts.authority.key() == oracle.authority, ErrorCode::Unauthorized);
        msg!("Oracle updated by: {} to price: {}", ctx.accounts.authority.key(), new_price);
        Ok(())
    }

    /// VULNERABILITY #2 & #8: PDA collision via seed reuse + AccountInfo oracle bypass
    /// Attacker can create market with same seeds or supply fake oracle
    pub fn create_market(
        ctx: Context<CreateMarket>,
        market_id: u64,
    ) -> Result<()> {
        let market = &mut ctx.accounts.market;
        let config = &mut ctx.accounts.config;
        
        market.market_id = market_id;
        market.supply_mint = ctx.accounts.supply_mint.key();
        market.collateral_mint = ctx.accounts.collateral_mint.key();
        
        // VULNERABILITY #8: AccountInfo allows ANY account as oracle
        market.supply_oracle = ctx.accounts.supply_oracle.key();
        market.collateral_oracle = ctx.accounts.collateral_oracle.key();
        
        market.total_supply = 0;
        market.total_borrows = 0;
        market.vault = ctx.accounts.vault.key();
        
        config.total_markets += 1;
        
        msg!("Market {} created with vault: {}", market_id, ctx.accounts.vault.key());
        Ok(())
    }

    /// VULNERABILITY #3: No subtraction from user_supply_account
    /// VULNERABILITY #4: Transfer success not verified, infinite cToken minting
    pub fn supply(ctx: Context<Supply>, amount: u64) -> Result<()> {
        let market = &mut ctx.accounts.market;
        let user_supply = &mut ctx.accounts.user_supply_account;
        
        // Initialize user supply account if needed
        if user_supply.owner == Pubkey::default() {
            user_supply.owner = ctx.accounts.user.key();
            user_supply.market = market.key();
            user_supply.ctoken_balance = 0;
        }
        
        // VULNERABILITY #4: Transfer without verification
        // Attacker can pass in accounts that fail transfer but still get credit
        let transfer_accounts = Transfer {
            from: ctx.accounts.user_token_account.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
            authority: ctx.accounts.user.to_account_info(),
        };
        
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            transfer_accounts,
        );
        
        // This might fail, but we don't check!
        let _ = token::transfer(cpi_ctx, amount);
        
        // VULNERABILITY #3: All math happens but no subtraction from user balance
        let ctoken_amount = amount; // Simplified 1:1 ratio for POC
        
        user_supply.ctoken_balance += ctoken_amount;
        market.total_supply += amount;
        // MISSING: Check actual token balance change
        // MISSING: Verify transfer succeeded
        
        msg!("User {} supplied {} tokens, cToken balance: {}", 
             ctx.accounts.user.key(), amount, user_supply.ctoken_balance);
        Ok(())
    }

    /// VULNERABILITY #6: No PDA verification - attacker can swap market PDA
    /// VULNERABILITY #5: CpiContext::new lacks signer seeds for vault withdrawal
    pub fn withdraw(ctx: Context<Withdraw>, ctoken_amount: u64) -> Result<()> {
        let market = &mut ctx.accounts.market;
        let user_supply = &mut ctx.accounts.user_supply_account;
        
        // VULNERABILITY #6: No verification that market PDA matches expected derivation
        // Attacker can bring their own fake market PDA with inflated balances
        // MISSING: 
        // let (expected_market, _) = Pubkey::find_program_address(
        //     &[b"market", market.market_id.to_le_bytes().as_ref(), 
        //       market.supply_mint.as_ref(), market.collateral_mint.as_ref()],
        //     ctx.program_id
        // );
        // require_keys_eq!(market.key(), expected_market);
        
        require!(
            user_supply.ctoken_balance >= ctoken_amount,
            ErrorCode::InsufficientBalance
        );
        
        let token_amount = ctoken_amount; // Simplified 1:1 ratio
        
        user_supply.ctoken_balance -= ctoken_amount;
        market.total_supply -= token_amount;
        
        // VULNERABILITY #5: CpiContext::new without signer seeds
        // Vault should be PDA owned by program, but no seeds provided
        let transfer_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.market.to_account_info(), // Should be PDA signer
        };
        
        // WRONG: Should be CpiContext::new_with_signer with PDA seeds
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            transfer_accounts,
        );
        
        // This will fail without proper signer seeds, but attacker can exploit
        // by providing their own vault that they control
        token::transfer(cpi_ctx, token_amount)?;
        
        msg!("User {} withdrew {} tokens", ctx.accounts.user.key(), token_amount);
        Ok(())
    }

    /// Borrow function using oracle price (vulnerable to oracle manipulation)
    pub fn borrow(ctx: Context<Borrow>, amount: u64) -> Result<()> {
        let market = &mut ctx.accounts.market;
        let user_supply = &ctx.accounts.user_supply_account;
        let user_borrow = &mut ctx.accounts.user_borrow_account;
        
        // Initialize user borrow account if needed
        if user_borrow.owner == Pubkey::default() {
            user_borrow.owner = ctx.accounts.user.key();
            user_borrow.market = market.key();
            user_borrow.borrow_amount = 0;
        }
        
        // Get oracle prices - VULNERABLE to fake oracles (#1, #7, #8)
        let supply_oracle = &ctx.accounts.supply_oracle;
        let collateral_price = supply_oracle.price;
        
        // Calculate collateral value (simplified)
        let collateral_value = user_supply.ctoken_balance.checked_mul(collateral_price)
            .ok_or(ErrorCode::MathOverflow)?;
        let max_borrow = collateral_value.checked_mul(80)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(100)
            .ok_or(ErrorCode::MathOverflow)?;
        
        require!(
            user_borrow.borrow_amount + amount <= max_borrow,
            ErrorCode::InsufficientCollateral
        );
        
        user_borrow.borrow_amount += amount;
        market.total_borrows += amount;
        
        // Transfer tokens (same vulnerabilities as supply)
        let transfer_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: ctx.accounts.market.to_account_info(),
        };
        
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            transfer_accounts,
        );
        
        token::transfer(cpi_ctx, amount)?;
        
        msg!("User {} borrowed {} tokens using fake oracle price {}", 
             ctx.accounts.user.key(), amount, collateral_price);
        Ok(())
    }
}


#[account]
pub struct Config {
    pub admin: Pubkey,
    pub total_markets: u64,
}

#[account]
pub struct Oracle {
    pub price: u64,
    pub authority: Pubkey,
    pub last_update: i64,
}

#[account]
pub struct Market {
    pub market_id: u64,
    pub supply_mint: Pubkey,
    pub collateral_mint: Pubkey,
    pub supply_oracle: Pubkey,
    pub collateral_oracle: Pubkey,
    pub vault: Pubkey,
    pub total_supply: u64,
    pub total_borrows: u64,
}

#[account]
pub struct UserSupplyAccount {
    pub owner: Pubkey,
    pub market: Pubkey,
    pub ctoken_balance: u64,
}

#[account]
pub struct UserBorrowAccount {
    pub owner: Pubkey,
    pub market: Pubkey,
    pub borrow_amount: u64,
}


#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 32 + 8)]
    pub config: Account<'info, Config>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateOracle<'info> {
    #[account(init, payer = signer, space = 8 + 8 + 32 + 8)]
    pub oracle: Account<'info, Oracle>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateOracle<'info> {
    #[account(mut)]
    pub oracle: Account<'info, Oracle>,
    pub authority: Signer<'info>, // VULNERABILITY #7: Not checked against oracle.authority
}

#[derive(Accounts)]
#[instruction(market_id: u64)]
pub struct CreateMarket<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 8 + 32 + 32 + 32 + 32 + 32 + 8 + 8,
        // VULNERABILITY #2: Predictable seeds allow collision
        seeds = [
            b"market",
            market_id.to_le_bytes().as_ref(),
            supply_mint.key().as_ref(),
            collateral_mint.key().as_ref()
        ],
        bump
    )]
    pub market: Account<'info, Market>,
    #[account(mut)]
    pub config: Account<'info, Config>,
    pub supply_mint: Account<'info, Mint>,
    pub collateral_mint: Account<'info, Mint>,
    
    // VULNERABILITY #8: AccountInfo instead of Account<Oracle>
    /// CHECK: This is intentionally vulnerable - accepts any account
    pub supply_oracle: AccountInfo<'info>,
    /// CHECK: This is intentionally vulnerable - accepts any account
    pub collateral_oracle: AccountInfo<'info>,
    
    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Supply<'info> {
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    #[account(
        init_if_needed,
        payer = user,
        space = 8 + 32 + 32 + 8,
        seeds = [b"user_supply", user.key().as_ref(), market.key().as_ref()],
        bump
    )]
    pub user_supply_account: Account<'info, UserSupplyAccount>,
    
    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    #[account(
        mut,
        seeds = [b"user_supply", user.key().as_ref(), market.key().as_ref()],
        bump
    )]
    pub user_supply_account: Account<'info, UserSupplyAccount>,
    
    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct Borrow<'info> {
    #[account(mut)]
    pub market: Account<'info, Market>,
    
    #[account(
        seeds = [b"user_supply", user.key().as_ref(), market.key().as_ref()],
        bump
    )]
    pub user_supply_account: Account<'info, UserSupplyAccount>,
    
    #[account(
        init_if_needed,
        payer = user,
        space = 8 + 32 + 32 + 8,
        seeds = [b"user_borrow", user.key().as_ref(), market.key().as_ref()],
        bump
    )]
    pub user_borrow_account: Account<'info, UserBorrowAccount>,
    
    pub supply_oracle: Account<'info, Oracle>,
    
    #[account(mut)]
    pub vault: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub user: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}


#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient collateral")]
    InsufficientCollateral,
    #[msg("Unauthorized")]
    Unauthorized,
    #[msg("Math overflow")]
    MathOverflow,
}